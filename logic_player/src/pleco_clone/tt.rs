//! Module for the `TranspositionTable`, a type of hash-map where Zobrist Keys map to information about a position.
//!
//! A [`TranspositionTable`] is a structure to quickly lookup chess positions and determine information from them.
//! It maps from Board positions to information such as the evaluation of that position, the best move found so far,
//! the depth that move was found at, etc.
//!
//! Specifically, a [`TranspositionTable`] maps from a u64 to an [`Entry`].
//!
//! This is a lock-free table, able to be concurrently accessed by multiple threads quickly. However, there is still
//! a risk of collisions & over-writes when using this with multiple threads. Furthermore, Keys (generated by a
//! zobrist hash) are not guaranteed to uniquely map to a specific chess position, and unique keys are not
//! guaranteed to map to unique buckets inside the table.  The chances of collision are extremely
//! low, but it's still something to take into account when using the transposition table.
//!
//! # Examples
//!
//! Here, we create a new [`TranspositionTable`] with 4,000 entries, and search for a key. Because this table is empty,
//! found should return false. Now, we insert the data for an [`Entry`], and then search again for the key. Now, found
//! will be true, and we'll end up with the data we entered.
//!
//! ```ignore
//! let tt = TranspositionTable::new_num_entries(40000);
//! let prng = PRNG::init(932445561);
//!
//! let key: u64 = prng.rand();
//! let (found, entry): (bool, &mut Entry) = tt.probe(key);
//! assert!(!found);
//! entry.place(key, BitMove::new(0x555), 3, 4, 3, NodeBound::Exact);
//! let (found, entry) = tt.probe(key);
//! assert!(found);
//! ```
//!
//! [`TranspositionTable`]: ../../tools/tt/struct.TranspositionTable.html
//! [`Entry`]: ../../tools/tt/struct.Entry.html

use std::alloc::{self, handle_alloc_error, Layout};
use std::cell::UnsafeCell;
use std::cmp::min;
use std::mem;
use std::ptr::NonNull;

use super::prefetch_write;
use super::BitMove;
use super::PreFetchable;

// TODO: investigate potention for SIMD in key lookup
// Currently, there is now way to do this right now in rust without it being extensive.

pub type Key = u64;

/// BitMask for the [NodeTypeTimeBound]'s time data.
pub const TIME_MASK: u8 = 0b1111_1100;

/// BitMask for the retrieving a [NodeTypeTimeBound]'s [NodeType].
pub const NODE_TYPE_MASK: u8 = 0b0000_0011;

/// Number of Entries per Cluster.
pub const CLUSTER_SIZE: usize = 2;

const BYTES_PER_KB: usize = 1000;
const BYTES_PER_MB: usize = BYTES_PER_KB * 1000;

/// Designates the type of Node in the Chess Search tree.
/// See the [ChessWiki](https://chessprogramming.wikispaces.com/Node+Types) for more information
/// about PV Node types and their use.
#[derive(Copy, Clone, Eq, PartialEq)]
#[repr(u8)]
pub enum NodeBound {
    NoBound = 0,
    LowerBound = 1,
    UpperBound = 2,
    Exact = 3,
}

/// Abstraction for combining the 'time' a node was found alongside the `NodeType`.
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct NodeTypeTimeBound {
    data: u8,
}

impl NodeTypeTimeBound {
    /// Updates the [NodeType] of an entry.
    pub fn update_bound(&mut self, node_type: NodeBound, gen: u8) {
        self.data = (self.data & TIME_MASK) | node_type as u8 | gen;
    }

    /// Updates the time field of an entry.
    pub fn update_time(&mut self, time_bound: u8) {
        self.data = (self.data & NODE_TYPE_MASK) | time_bound;
    }
}

// 2 bytes + 2 bytes + 4 Byte + 4 byte + 1 + 1 = 14 Bytes

/// Structure defining a singular Entry in a table, containing the `BestMove` found,
/// the score of that node, the type of Node, depth found, as well as a key uniquely defining
/// the node.
#[derive(Clone, PartialEq)]
#[repr(C)]
pub struct Entry {
    pub partial_key: u16,
    pub best_move: BitMove, // What was the best move found here?
    pub score: f32,         // What was the Score of this node?
    pub eval: f32,          // What is the evaluation of this node
    pub depth: i8,          // How deep was this Score Found?
    pub time_node_bound: NodeTypeTimeBound,
}

impl Entry {
    /// Rewrites over an Entry.
    pub fn place(
        &mut self,
        key: Key,
        best_move: BitMove,
        score: f32,
        eval: f32,
        depth: i16,
        node_type: NodeBound,
        gen: u8,
    ) {
        let partial_key = key.wrapping_shr(48) as u16;

        if partial_key != self.partial_key {
            self.best_move = best_move;
        }

        if partial_key != self.partial_key
            || node_type == NodeBound::Exact
            || depth > self.depth as i16 - 4
        {
            self.partial_key = partial_key;
            self.score = score;
            self.eval = eval;
            self.depth = depth as i8;
            self.time_node_bound.update_bound(node_type, gen);
        }
    }

    /// Returns the current search time of the node.
    pub fn time(&self) -> u8 {
        self.time_node_bound.data & TIME_MASK
    }

    /// Returns the [NodeType] of an Entry.
    pub fn node_type(&self) -> NodeBound {
        match self.time_node_bound.data & NODE_TYPE_MASK {
            0 => NodeBound::NoBound,
            1 => NodeBound::LowerBound,
            2 => NodeBound::UpperBound,
            _ => NodeBound::Exact,
        }
    }

    /// Returns the value of the node in respect to the depth searched && when it was placed into the TranspositionTable.
    pub fn time_value(&self, curr_time: u8) -> i16 {
        let inner: i16 = ((259i16).wrapping_add(curr_time as i16))
            .wrapping_sub(self.time_node_bound.data as i16)
            & 0b1111_1100;
        (self.depth as i16).wrapping_sub(inner).wrapping_mul(2)
    }
}

// 28 bytes + 4 = 32 Bytes
/// Structure containing multiple Entries all mapped to by the same zobrist key.
#[repr(C)]
pub struct Cluster {
    pub entry: [Entry; CLUSTER_SIZE],
    pub padding: [u8; 4],
}

// clusters -> Pointer to the clusters
// cap -> n number of clusters (So n * CLUSTER_SIZE) number of entries
// time age -> documenting when an entry was placed

/// Structure for representing a `TranspositionTable`. A Transposition Table is a type
/// of HashTable that maps Zobrist Keys to information about that position, including the best move
/// found, score, depth the move was found at, and other information.
pub struct TranspositionTable {
    clusters: UnsafeCell<NonNull<Cluster>>, // pointer to the heap
    cap: UnsafeCell<usize>, // number of clusters, so (So n * CLUSTER_SIZE) number of entries
    time_age: UnsafeCell<u8>, // documenting at which root position an entry was placed
}

impl TranspositionTable {
    /// Creates new with a size of around 'mb_size'. Actual size is the nearest power
    /// of 2 times the size of a Cluster rounded down.
    ///
    /// # Panics
    ///
    /// mb_size should be > 0, or else a panic will occur
    pub fn new(mb_size: usize) -> Self {
        assert!(mb_size > 0);
        let mut num_clusters: usize = (mb_size * BYTES_PER_MB) / mem::size_of::<Cluster>();
        num_clusters = num_clusters.next_power_of_two() / 2;
        TranspositionTable::new_num_clusters(num_clusters)
    }

    /// Creates new TT rounded up to the nearest power of two number of Clusters.
    ///
    /// # Panics
    ///
    /// Size should be > 0, or else a panic will occur
    pub fn new_num_clusters(num_clusters: usize) -> Self {
        TranspositionTable::create(num_clusters.next_power_of_two())
    }

    // Creates new TT with the number of Clusters being size. size must be a power of two.
    fn create(size: usize) -> Self {
        assert_eq!(size.count_ones(), 1);
        assert!(size > 0);
        TranspositionTable {
            clusters: UnsafeCell::new(alloc_room(size)),
            cap: UnsafeCell::new(size),
            time_age: UnsafeCell::new(0),
        }
    }

    /// Returns the number of clusters the Transposition Table holds.
    #[inline(always)]
    pub fn num_clusters(&self) -> usize {
        unsafe { *self.cap.get() }
    }

    // Called each time a new position is searched.
    #[inline]
    pub fn new_search(&self) {
        unsafe {
            let c = self.time_age.get();
            *c = (*c).wrapping_add(4);
        }
    }

    /// Returns the current time age of a TT.
    #[inline]
    pub fn time_age(&self) -> u8 {
        unsafe { *self.time_age.get() }
    }

    /// Probes the Transposition Table for a specified Key. Returns (true, entry) if either (1) an
    /// Entry corresponding to the current key is found, or an Open Entry slot is found for the key.
    /// In the case of an open Entry, the entry can be tested for its contents by using `Entry::is_empty()`.
    /// If no entry is found && there are no open entries, returns the entry that is is most irrelevent to
    /// the current search, e.g. has the shallowest depth or was found in a previous search.
    ///
    /// If 'true' is returned, the Entry is guaranteed to have the correct time.
    pub fn probe(&self, key: Key) -> (bool, &mut Entry) {
        let partial_key: u16 = (key).wrapping_shr(48) as u16;

        unsafe {
            let cluster: *mut Cluster = self.cluster(key);
            let init_entry: *mut Entry = cluster_first_entry(cluster);

            // for each entry
            for i in 0..CLUSTER_SIZE {
                // get a pointer to the specified entry
                let entry_ptr: *mut Entry = init_entry.offset(i as isize);
                // convert to &mut
                let entry: &mut Entry = &mut (*entry_ptr);

                // found a spot
                if entry.partial_key == 0 || entry.partial_key == partial_key {
                    // if age is incorrect, make it correct
                    if entry.time() != self.time_age() && entry.partial_key != 0 {
                        entry.time_node_bound.update_time(self.time_age());
                    }

                    // Return the spot
                    return (entry.partial_key != 0, entry);
                }
            }

            let mut replacement: *mut Entry = init_entry;
            let mut replacement_score: i16 = (&*replacement).time_value(self.time_age());

            // Table is full, find the best replacement based on depth and time placed there
            for i in 1..CLUSTER_SIZE {
                let entry_ptr: *mut Entry = init_entry.offset(i as isize);
                let entry_score: i16 = (&*entry_ptr).time_value(self.time_age());
                if entry_score < replacement_score {
                    replacement = entry_ptr;
                    replacement_score = entry_score;
                }
            }
            // return the best place to replace
            (false, &mut (*replacement))
        }
    }

    /// Returns the cluster of a given key.
    #[inline]
    fn cluster(&self, key: Key) -> *mut Cluster {
        let index: usize = ((self.num_clusters() - 1) as u64 & key) as usize;
        unsafe { (*self.clusters.get()).as_ptr().offset(index as isize) }
    }

    /// De-allocates the current heap.
    unsafe fn de_alloc(&self) {
        let layout = Layout::from_size_align(*self.cap.get(), 2).unwrap();
        let ptr: *mut u8 = mem::transmute(*self.clusters.get());
        //        alloc::dealloc(ptr, Layout::array::<Cluster>(*self.cap.get()).unwrap());
        alloc::dealloc(ptr, layout);
    }

    /// Returns the % of the hash table that is full.
    pub fn hash_percent(&self) -> f64 {
        unsafe {
            let clusters_scanned: u64 = min((*self.cap.get() - 1) as u64, 333);
            let mut hits: f64 = 0.0;

            for i in 0..clusters_scanned {
                let cluster = self.cluster(i + 1);
                let init_entry: *mut Entry = cluster_first_entry(cluster);
                for e in 0..CLUSTER_SIZE {
                    // get a pointer to the specified entry
                    let entry_ptr: *mut Entry = init_entry.offset(e as isize);
                    let entry: &Entry = &(*entry_ptr);
                    if entry.time() == self.time_age() {
                        hits += 1.0;
                    }
                }
            }
            (hits * 100.0) / (clusters_scanned * CLUSTER_SIZE as u64) as f64
        }
    }
}

impl PreFetchable for TranspositionTable {
    /// Pre-fetches a particular key. This means bringing it into the cache for faster eventual
    /// access.
    #[inline(always)]
    fn prefetch(&self, key: u64) {
        let index: usize = ((self.num_clusters() - 1) as u64 & key) as usize;
        unsafe {
            let ptr = (*self.clusters.get()).as_ptr().offset(index as isize);
            prefetch_write(ptr);
        };
    }
}

impl Drop for TranspositionTable {
    fn drop(&mut self) {
        unsafe {
            self.de_alloc();
        }
    }
}

/// Returns the first entry of a cluster.
#[inline]
unsafe fn cluster_first_entry(cluster: *mut Cluster) -> *mut Entry {
    (*cluster).entry.get_unchecked_mut(0) as *mut Entry
}

// Return a Heap Allocation of Size number of Clusters.
#[inline]
fn alloc_room(size: usize) -> NonNull<Cluster> {
    unsafe {
        let size = size * mem::size_of::<Cluster>();
        let layout = Layout::from_size_align(size, 2).unwrap();
        // let layout = Layout::array::<Cluster>(size).unwrap();
        let ptr: *mut u8 = alloc::alloc_zeroed(layout);
        let new_ptr: NonNull<Cluster> = match NonNull::new(ptr) {
            Some(ptr) => ptr.cast(),
            _ => handle_alloc_error(layout),
        };
        new_ptr
    }
}
